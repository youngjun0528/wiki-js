---
title: 03.Spring5
description: 
published: true
date: 2021-05-14T05:24:13.292Z
tags: 
editor: markdown
dateCreated: 2021-05-14T00:01:30.145Z
---

## 스프링 제어의 역전(IoC)과 의존성 주입(DI)
### 빈(Bean)
스프링 컨테이너가 관리하는 객체

### Java 객체 의존성 관리
1. 객체가 직접 의존 관계에 있는 객체들의 생성자를 호출
```java
public class RegService(){
	private MSender mSender;
  public RegService(){
  	// 의존하는 객체를 인스턴스화 한다.
    this.mSender = new MSender();
  }
}
```
2. Look-Up 패턴을 활용해 의존성을 찾아 배치
```java
public class RegService(){
	private MSender mSender;
  public RegService(MSender mSender){
  	this.mSender = mSender;
  }
}

```
위의 RegService에서는 객체의 의존성을 제어하지 못하고, 스프링이 객체의 인스턴스화가 이루어진다.
이를 제어의 역전(Inversion of Control, IoC) 라고 한다.


### 어노테이션 기반의 설정

#### 빈 선언
1. @Component : 제네릭 스테레오 타입, 해당 클래스를 인스턴스화 한다.
2. @Service : 컴포넌트 어노테이션을 특수화 한 것으로 서비스 영역에서 선언한다.
3. @Repository : DAO(Data Sccess Object)를 나타낸다.
4. @Controller : 컴포넌트가 HTTP 요청을 받을 수 있는 Web 컨트롤러 임을 나타낸다.

#### 의존성 주입
반드시 필요한 의존선을 생성자를 통해 주입해야 마며, 최초 주입된 이후 의존성을 ReadOnly 상태이다.
선택적인 의존성을 세터/메소드를 통해 주입할 수 있다. 필드 기반 기반 주입은 지양한다.
1. 생성자 기반의 주입 : 생성자에 @Autowired 적용
```java
@Autowired
public MsgService(MsgRepository repo){
	this.repo = repo
}
```
2. 세터 기반/메소드 기반의 주입 : 메소드 선언 후 @Autowired 또는 @Required 적용
```java
@Required
public void setMsgService(MsgRepository repo){
	this.repo = repo
}
```
3. 핃드 기반의 주입 : 이 방법 사용시 세터 메소드는 별도 선언할 필요가 없다.
```java
@Autowired
private MsgRepository repo
```

## 스프링 MVC
### 자바 EE 서블릿
톰캣과 같은 애플리케이션 서버인 서블릿 컨테이너 내에서 동작
1. HTTP 요청이 도착하면 인증,로깅,감사와 같은 필터링 작업을 수행하는 필터리스트를 통과
	1.1 애플리케이션 서버는 첫번째 요청이 들어오면 HttpSession 인스턴스를 생성
  1.2 각 HttpSession 인스턴스는 Session ID 라는 Id를 가진다.
  1.3 HttpSessionListener / ServeltRequestListener 인터페이스를 구현해 HttpSession의 라이프사이클 이벤트를 수신
2. 특정 패턴과 일치하는 URI를 포함하는 요청을 처리할 수 있게 등록된 서블릿으로 전달
	2.1 Java EE 에서는 모든 HTTP 요청에 대해 HttpServletRequest 인스턴스가 생성
  2.2 서블릿은 @WebServlet 어노테이션을 적용
  2.3 doGet / doPost / doPost / doDelete
3. 서블릿이 요청에 대한 처리를 마치면 HTTP 응답은 동일 필터리스트를 통과한 후 클라이언트로 다시 전송
	3-1. Java EE 에서는 모든 HHTP 응답에 대해 HttpServletResponse 인스턴스가 생성
  3-2. Seesion ID를 HTTP의 응답해더에 쿠키로 전송

### DispatcherServelt
클래스 생성후 @Controller 어노테이션을 추가하고 @RequestMapping 어노테이션으로 특정 URI 패턴에 매핑 가능
```java
import org.springframework.web.bind.annotation.RequestBoby;
@Controller
@RequestMapping("/messages")
public class MessageController{
	@GetMapping("/welcome")
  @ResponseBoby
  public String welcome(){
  	return "welcome"
  }
}
```

### Views
핸들러의 반환값을 View 이름으로 사용하고 응답을 생성.
```java
import org.springframework.web.bind.annotation.RequestBoby;
@Controller
@RequestMapping("/messages")
public class MessageController{
	@GetMapping("/welcome")
  public String welcome(Model model){
  	model.addAttribute("message", "Hello")
  	return "welcome"
  }
}
```
```
// welcome.html
<strong> th:text="${message}"><strong>
```
